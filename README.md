# Lazy Ranges

STL. Адаптеры.

## Задача

Разработать библиотеку адаптеров для упрощенной работы с алгоритмами и контейнерами, реализующую
концепцию [конвейера](https://en.wikipedia.org/wiki/Pipeline_(Unix)),
аналогичную той, которая используется в Unix-системах. Целью является создание более удобного и выразительного способа
работы с контейнерами, позволяющего цепочечно применять алгоритмы к данным, что повышает читаемость и элегантность кода.

Вместо использования множества отдельных вызовов алгоритмов, задача решается с помощью концепции конвейера, где
результаты одной операции становятся входными данными для следующей.

Пример традиционного подхода:

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5, 6};
std::vector<int> result;

std::copy_if(vec.begin(), vec.end(), std::back_inserter(result), [](int i) { return i % 2; });
std::transform(result.begin(), result.end(), result.begin(), [](int i) { return i * i; });

for (int i : result)
    std::cout << i << " ";
```

Тот же пример с использованием подхода "конвейера":

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5, 6};

auto removed = vec | filter([](int i) { return i % 2; });
auto result = removed | transform([](int i) { return i * i; });

for (int i : result)
    std::cout << i << " ";
```

Или еще более компактно, с помощью конвейерной обработки:

```cpp
std::vector<int> vec = {1, 2, 3, 4, 5, 6};

for (int i : vec | filter([](int i) { return i % 2; }) | transform([](int i) { return i * i; }))
    std::cout << i << " ";
```

Отличием этого подхода от традиционного является ленивые вычисления и то, что адаптеры не копируют или не владеют
данными, а лишь выполняют трансформацию, фильтрацию и другие операции, когда это необходимо.

Этот принцип схож с тем, как работают
классы [std::string_view](https://en.cppreference.com/w/cpp/string/basic_string_view)
и [std::span](https://en.cppreference.com/w/cpp/container/span).

## Требуемые адаптеры

Библиотека должна включать несколько адаптеров, которые могут быть использованы для работы с контейнерами и должны
выдвигать собственные требования к ним с помощью static_assert:

* **transform** - преобразует элементы, аналогично алгоритму std::transform
* **filter** - фильтрует элементы по заданному условию
* **take** - возвращает только первые N элементов
* **drop** - пропускает первые N элементов
* **reverse** - реверсия
* **keys** - извлекает ключи для ассоциативных контейнеров
* **values** - извлекает значения для ассоциативных контейнеров

## Тесты

Все адаптеры и компоненты должны быть покрыты тестами с использованием
фреймворка [Google Test](http://google.github.io/googletest).

## NB

1. При реализации классов для их использования в `range-based for`, они должны соответствовать
   ряду [требований](https://en.cppreference.com/w/cpp/language/range-for).

2. Задача является упрощенной реализацией библиотеки std::ranges, поэтому использование этой библиотеки в коде
   запрещено. Однако, вы можете ознакомиться с её реализацией для того, чтобы перенять идеи и подходы.
